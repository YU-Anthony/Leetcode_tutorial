# Answer
> 参考资料：<br>
> [LeetCode 684. Redundant Connection 解题报告（python)](https://blog.csdn.net/Orientliu96/article/details/104452725)
> [Python: Easy to understand: GRAPH - DFS](https://leetcode.com/problems/redundant-connection/discuss/1295991/Python%3A-Easy-to-understand%3A-GRAPH-DFS)

This ia Graph related problem that emphasizes on finding a cycle in the graph.

In general graph cycle finding problem we just need to say that whether a cycle exists or not, but in this problem we need to **return the edge** that caused the cycle and if multiple edges caused the cycle then we need to return the later occuring edge.
### Solution: Union find
> 题目大意: 给出了一个有环无向图的各个边，找出能去除的边，使得这个图不含环（即为树）。

用union-find是个不错的策略。我们首先将每个节点初始化为一个独立的节点，然后依次添加边。在添加之前，我们首先判断原来两个节点是否已经处于同一个component，如果是，则说明添加该边将形成环，所以直接返回该边；否则就可以直接添加边了。

```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = [0]*(len(edges) + 1)
        def find(x):
            if parent[x] == 0:
                return x
            parent[x] = find(parent[x])
            return parent[x]
        
        def union(x,y):
            rootx = find(x)
            rooty = find(y)
            if rootx == rooty:
                return False
            else:
                parent[rootx] = rooty
            return True
        
        for x,y in edges:
            if not union(x,y):
                return [x,y]
```